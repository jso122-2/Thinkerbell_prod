#!/usr/bin/env python3
"""
File Sync Runner for Thinkerbell
Automatically syncs files from Windows environment to Ubuntu environment
"""

import os
import shutil
import json
import hashlib
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Set, Tuple

class FileSyncRunner:
    """Dedicated file sync runner for Thinkerbell environment"""
    
    def __init__(self, source_dir: str = ".", target_dir: str = "/root/scripts/Thinkerbell/Thinkerbell_template_pipeline"):
        self.source_dir = Path(source_dir)
        self.target_dir = Path(target_dir)
        self.sync_log = []
        self.file_hashes = {}
        
    def calculate_file_hash(self, file_path: Path) -> str:
        """Calculate MD5 hash of a file"""
        try:
            with open(file_path, 'rb') as f:
                return hashlib.md5(f.read()).hexdigest()
        except Exception:
            return ""
    
    def get_file_list(self, directory: Path, extensions: List[str] = None) -> List[Path]:
        """Get list of files in directory with optional extension filter"""
        files = []
        if extensions:
            for ext in extensions:
                files.extend(directory.glob(f"**/*{ext}"))
        else:
            files = list(directory.rglob("*"))
            files = [f for f in files if f.is_file()]
        return files
    
    def sync_file(self, source_file: Path, target_file: Path) -> bool:
        """Sync a single file from source to target"""
        try:
            # Create target directory if it doesn't exist
            target_file.parent.mkdir(parents=True, exist_ok=True)
            
            # Copy file
            shutil.copy2(source_file, target_file)
            
            # Update hash
            self.file_hashes[str(target_file)] = self.calculate_file_hash(target_file)
            
            self.sync_log.append({
                "action": "sync",
                "source": str(source_file),
                "target": str(target_file),
                "timestamp": datetime.now().isoformat(),
                "success": True
            })
            
            return True
        except Exception as e:
            self.sync_log.append({
                "action": "sync",
                "source": str(source_file),
                "target": str(target_file),
                "timestamp": datetime.now().isoformat(),
                "success": False,
                "error": str(e)
            })
            return False
    
    def sync_directory_structure(self) -> Dict[str, int]:
        """Sync the complete directory structure"""
        print("ğŸ”„ Starting file sync from Windows to Ubuntu...")
        
        # Define file types to sync
        python_files = self.get_file_list(self.source_dir, [".py"])
        shell_files = self.get_file_list(self.source_dir, [".sh"])
        json_files = self.get_file_list(self.source_dir, [".json"])
        md_files = self.get_file_list(self.source_dir, [".md"])
        txt_files = self.get_file_list(self.source_dir, [".txt"])
        
        all_files = python_files + shell_files + json_files + md_files + txt_files
        
        stats = {
            "total_files": len(all_files),
            "synced_files": 0,
            "failed_files": 0,
            "new_files": 0,
            "updated_files": 0
        }
        
        for source_file in all_files:
            # Calculate relative path
            rel_path = source_file.relative_to(self.source_dir)
            target_file = self.target_dir / rel_path
            
            # Check if file needs updating
            needs_update = True
            if target_file.exists():
                source_hash = self.calculate_file_hash(source_file)
                target_hash = self.calculate_file_hash(target_file)
                needs_update = source_hash != target_hash
            
            if needs_update:
                success = self.sync_file(source_file, target_file)
                if success:
                    stats["synced_files"] += 1
                    if target_file.exists():
                        stats["updated_files"] += 1
                    else:
                        stats["new_files"] += 1
                else:
                    stats["failed_files"] += 1
                    
                # Print progress
                status = "âœ…" if success else "âŒ"
                print(f"{status} {rel_path}")
        
        return stats
    
    def create_ubuntu_launcher(self) -> bool:
        """Create Ubuntu-specific launcher script"""
        try:
            launcher_content = f"""#!/bin/bash

# Thinkerbell Ubuntu Launcher
# Auto-generated by file_sync_runner.py

SCRIPT_DIR="{self.target_dir}"
PYTHON_CMD="python3"

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

print_status() {{
    echo -e "${{GREEN}}[INFO]${{NC}} $1"
}}

print_warning() {{
    echo -e "${{YELLOW}}[WARNING]${{NC}} $1"
}}

print_error() {{
    echo -e "${{RED}}[ERROR]${{NC}} $1"
}}

print_header() {{
    echo -e "${{BLUE}}================================${{NC}}"
    echo -e "${{BLUE}}$1${{NC}}"
    echo -e "${{BLUE}}================================${{NC}}"
}}

# Function to check if we're in the right directory
check_environment() {{
    if [ ! -d "$SCRIPT_DIR" ]; then
        print_error "Thinkerbell directory not found at $SCRIPT_DIR"
        print_status "Creating directory structure..."
        mkdir -p "$SCRIPT_DIR"
    fi
    
    cd "$SCRIPT_DIR" 2>/dev/null || {{
        print_error "Cannot access $SCRIPT_DIR"
        exit 1
    }}
}}

# Function to install dependencies
install_dependencies() {{
    print_header "Installing Dependencies"
    
    # Check if pip is available
    if ! command -v pip3 &> /dev/null; then
        print_error "pip3 not found. Installing..."
        sudo apt update
        sudo apt install -y python3-pip
    fi
    
    # Install required packages
    print_status "Installing Python dependencies..."
    pip3 install numpy pandas scikit-learn nltk textstat regex sentence-transformers transformers torch pydantic jsonschema pathlib2 tqdm
    
    print_status "Dependencies installed successfully!"
}}

# Function to show status
show_status() {{
    print_header "Thinkerbell System Status"
    
    check_environment
    
    print_status "Checking Python environment..."
    python3 --version
    
    print_status "Checking available tools..."
    ls -la *.py 2>/dev/null || print_warning "No Python tools found"
    
    print_status "Running system status check..."
    $PYTHON_CMD synthetic_data_launcher.py --status
}}

# Function to test components
test_components() {{
    print_header "Testing Components"
    
    check_environment
    
    print_status "Running component tests..."
    $PYTHON_CMD synthetic_data_launcher.py --test
}}

# Function to generate validation batch
generate_validation() {{
    local size=${{1:-50}}
    
    print_header "Generating Validation Batch"
    
    check_environment
    
    print_status "Generating validation batch of $size samples..."
    $PYTHON_CMD synthetic_data_launcher.py --validation-batch $size
}}

# Function to generate full dataset
generate_dataset() {{
    local mode=${{1:-individual}}
    local samples=${{2:-1000}}
    local batch_size=${{3:-100}}
    
    print_header "Generating Dataset"
    
    check_environment
    
    print_status "Generating $samples samples in $mode mode..."
    $PYTHON_CMD synthetic_data_launcher.py --mode $mode --samples $samples --batch-size $batch_size
}}

# Function to run quality analysis
quality_analysis() {{
    local dataset_path=${{1:-synthetic_dataset}}
    
    print_header "Quality Analysis"
    
    check_environment
    
    print_status "Running quality analysis on $dataset_path..."
    $PYTHON_CMD synthetic_data_launcher.py --quality-analysis $dataset_path
}}

# Function to show help
show_help() {{
    print_header "Thinkerbell Tools - Help"
    
    echo "Usage: $0 [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  status                    - Show system status"
    echo "  test                      - Test all components"
    echo "  install                   - Install dependencies"
    echo "  validation [SIZE]         - Generate validation batch (default: 50)"
    echo "  generate [MODE] [SAMPLES] - Generate full dataset"
    echo "  quality [PATH]            - Run quality analysis"
    echo "  help                      - Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 status"
    echo "  $0 test"
    echo "  $0 validation 100"
    echo "  $0 generate individual 1000"
    echo "  $0 generate monolithic 500"
    echo "  $0 quality synthetic_dataset/"
    echo ""
    echo "Modes: individual, monolithic"
    echo "Default samples: 1000"
    echo "Default validation size: 50"
}}

# Function to sync files
sync_files() {{
    print_header "Syncing Files from Windows Environment"
    
    check_environment
    
    print_status "Running file sync..."
    cd "$SCRIPT_DIR"
    python3 file_sync_runner.py --sync
    
    print_status "Files synced successfully!"
}}

# Main script logic
main() {{
    local command=${{1:-help}}
    
    case $command in
        "status")
            show_status
            ;;
        "test")
            test_components
            ;;
        "install")
            install_dependencies
            ;;
        "validation")
            generate_validation $2
            ;;
        "generate")
            generate_dataset $2 $3 $4
            ;;
        "quality")
            quality_analysis $2
            ;;
        "sync")
            sync_files
            ;;
        "help"|*)
            show_help
            ;;
    esac
}}

# Check if script is being sourced or executed
if [[ "${{BASH_SOURCE[0]}}" == "${{0}}" ]]; then
    # Script is being executed
    main "$@"
else
    # Script is being sourced
    print_status "Thinkerbell tools loaded. Use 'main' function to run commands."
fi

# Export functions for use in shell
export -f main show_status test_components generate_validation generate_dataset quality_analysis show_help sync_files
"""
            
            launcher_path = self.target_dir / "thinkerbell_ubuntu_launcher.sh"
            with open(launcher_path, 'w') as f:
                f.write(launcher_content)
            
            # Make executable
            os.chmod(launcher_path, 0o755)
            
            print(f"âœ… Created Ubuntu launcher: {launcher_path}")
            return True
            
        except Exception as e:
            print(f"âŒ Failed to create Ubuntu launcher: {e}")
            return False
    
    def create_install_script(self) -> bool:
        """Create installation script for Ubuntu"""
        try:
            install_content = f"""#!/bin/bash

# Thinkerbell Ubuntu Installation Script
# Auto-generated by file_sync_runner.py

set -e

SCRIPT_DIR="{self.target_dir}"
LAUNCHER_PATH="$SCRIPT_DIR/thinkerbell_ubuntu_launcher.sh"

print_status() {{
    echo -e "\\033[0;32m[INFO]\\033[0m $1"
}}

print_error() {{
    echo -e "\\033[0;31m[ERROR]\\033[0m $1"
}}

print_header() {{
    echo -e "\\033[0;34m================================\\033[0m"
    echo -e "\\033[0;34m$1\\033[0m"
    echo -e "\\033[0;34m================================\\033[0m"
}}

print_header "Thinkerbell Ubuntu Installation"

# Create directory structure
print_status "Creating directory structure..."
mkdir -p "$SCRIPT_DIR"

# Copy files
print_status "Copying files..."
cp -r . "$SCRIPT_DIR/"

# Make launcher executable
if [ -f "$LAUNCHER_PATH" ]; then
    chmod +x "$LAUNCHER_PATH"
    print_status "Made launcher executable"
fi

# Install Python dependencies
print_status "Installing Python dependencies..."
pip3 install numpy pandas scikit-learn nltk textstat regex sentence-transformers transformers torch pydantic jsonschema pathlib2 tqdm

# Create aliases
print_status "Creating bash aliases..."
if ! grep -q "thinkerbell" ~/.bashrc; then
    echo "" >> ~/.bashrc
    echo "# Thinkerbell Tools Aliases" >> ~/.bashrc
    echo "alias thinkerbell='source $LAUNCHER_PATH'" >> ~/.bashrc
    echo "alias tb='source $LAUNCHER_PATH'" >> ~/.bashrc
    print_status "Added aliases to .bashrc"
else
    print_status "Aliases already exist in .bashrc"
fi

print_header "Installation Complete!"

echo "ğŸ‰ Thinkerbell has been installed successfully!"
echo ""
echo "ğŸ“ Files are located at: $SCRIPT_DIR"
echo "ğŸ› ï¸  Launcher: $LAUNCHER_PATH"
echo ""
echo "ğŸš€ Usage:"
echo "  source $LAUNCHER_PATH"
echo "  main status"
echo "  main test"
echo "  main validation 50"
echo "  main generate individual 1000"
echo ""
echo "ğŸ“‹ Or use the alias:"
echo "  thinkerbell status"
echo "  tb test"
echo ""
echo "âš ï¸  Note: You may need to restart your terminal or run 'source ~/.bashrc' to use the aliases."
"""
            
            install_path = self.target_dir / "install_ubuntu.sh"
            with open(install_path, 'w') as f:
                f.write(install_content)
            
            # Make executable
            os.chmod(install_path, 0o755)
            
            print(f"âœ… Created installation script: {install_path}")
            return True
            
        except Exception as e:
            print(f"âŒ Failed to create installation script: {e}")
            return False
    
    def save_sync_log(self) -> bool:
        """Save sync log to file"""
        try:
            log_path = self.target_dir / "sync_log.json"
            with open(log_path, 'w') as f:
                json.dump({
                    "sync_timestamp": datetime.now().isoformat(),
                    "source_dir": str(self.source_dir),
                    "target_dir": str(self.target_dir),
                    "file_hashes": self.file_hashes,
                    "sync_log": self.sync_log
                }, f, indent=2)
            
            print(f"âœ… Saved sync log: {log_path}")
            return True
        except Exception as e:
            print(f"âŒ Failed to save sync log: {e}")
            return False
    
    def run_full_sync(self) -> Dict[str, any]:
        """Run complete file sync operation"""
        print("ğŸš€ Thinkerbell File Sync Runner")
        print("=" * 50)
        
        # Create target directory
        self.target_dir.mkdir(parents=True, exist_ok=True)
        
        # Sync files
        stats = self.sync_directory_structure()
        
        # Create Ubuntu launcher
        launcher_created = self.create_ubuntu_launcher()
        
        # Create installation script
        install_created = self.create_install_script()
        
        # Save sync log
        log_saved = self.save_sync_log()
        
        # Print summary
        print("\nğŸ“Š Sync Summary:")
        print(f"  Total files processed: {stats['total_files']}")
        print(f"  Files synced: {stats['synced_files']}")
        print(f"  New files: {stats['new_files']}")
        print(f"  Updated files: {stats['updated_files']}")
        print(f"  Failed files: {stats['failed_files']}")
        print(f"  Ubuntu launcher created: {'âœ…' if launcher_created else 'âŒ'}")
        print(f"  Installation script created: {'âœ…' if install_created else 'âŒ'}")
        print(f"  Sync log saved: {'âœ…' if log_saved else 'âŒ'}")
        
        return {
            "stats": stats,
            "launcher_created": launcher_created,
            "install_created": install_created,
            "log_saved": log_saved
        }

def main():
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Thinkerbell File Sync Runner")
    parser.add_argument("--sync", action="store_true", help="Run full file sync")
    parser.add_argument("--source", type=str, default=".", help="Source directory")
    parser.add_argument("--target", type=str, default="/root/scripts/Thinkerbell/Thinkerbell_template_pipeline", help="Target directory")
    
    args = parser.parse_args()
    
    runner = FileSyncRunner(args.source, args.target)
    
    if args.sync:
        result = runner.run_full_sync()
        return result
    else:
        print("Use --sync to run the file sync operation")
        return None

if __name__ == "__main__":
    main() 